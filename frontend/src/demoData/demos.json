{
  "demos": [
    {
      "id": "demo-rust-vs-go",
      "question": "Should I learn Rust or Go for backend development in 2026?",
      "models": ["openai/gpt-5.1", "google/gemini-3-pro-preview", "anthropic/claude-sonnet-4.5"],
      "lead_model": "google/gemini-3-pro-preview",
      "stage1": [
        {
          "model": "openai/gpt-5.1",
          "response": "For backend development in 2026, both Rust and Go are excellent choices, but they serve different needs.\n\n**Go** is the pragmatic choice if you want to:\n- Get productive quickly (simpler syntax, faster learning curve)\n- Build microservices and APIs with excellent concurrency\n- Work in cloud-native environments (Kubernetes, Docker were built in Go)\n- Join teams at companies like Google, Uber, or Cloudflare\n\n**Rust** is better if you:\n- Need maximum performance and memory safety without garbage collection\n- Are building systems-level software, game engines, or WebAssembly\n- Want to work on blockchain, embedded systems, or security-critical code\n- Value catching bugs at compile time over runtime\n\n**My recommendation:** Start with Go if you're focused on typical backend/API work. The ecosystem is mature, deployment is simple (single binary), and the job market is strong. Learn Rust later when you have a specific use case that demands its unique strengths."
        },
        {
          "model": "google/gemini-3-pro-preview",
          "response": "This is a great question that many developers face. Let me break down the key considerations:\n\n## Go: The Practical Choice\n\nGo excels at:\n- **Simplicity**: Intentionally minimal syntax means less cognitive overhead\n- **Concurrency**: Goroutines and channels make concurrent programming intuitive\n- **Fast compilation**: Near-instant build times improve developer experience\n- **Deployment**: Single static binary, no runtime dependencies\n- **Ecosystem**: Excellent tooling (go fmt, go test, go mod) built-in\n\n## Rust: The Performance Choice\n\nRust shines when:\n- **Zero-cost abstractions**: Pay only for what you use\n- **Memory safety**: No garbage collector, but no memory bugs either\n- **Performance-critical systems**: When every microsecond matters\n- **WebAssembly**: Best-in-class WASM compilation\n- **Correctness guarantees**: The borrow checker catches entire categories of bugs\n\n## 2026 Market Reality\n\nGo has broader adoption in typical backend roles. Rust is growing fast but remains more specialized. For career flexibility, Go opens more doors today. For technical depth and future-proofing in systems programming, Rust is unmatched.\n\n**Bottom line**: Learn Go first for immediate employability in backend roles. Add Rust when you're ready to level up or have performance-critical needs."
        },
        {
          "model": "anthropic/claude-sonnet-4.5",
          "response": "I'll give you a framework for deciding rather than a prescriptive answer, since the \"right\" choice depends heavily on your context.\n\n**Choose Go if your primary goals are:**\n\n1. **Fast time-to-productivity** - Go's simplicity means you'll be writing production code within weeks, not months\n2. **Building web services** - Go's standard library and ecosystem (Gin, Echo, Chi) are battle-tested for HTTP services\n3. **DevOps/Infrastructure** - The cloud-native ecosystem is Go-dominated (Kubernetes, Terraform, Docker, Prometheus)\n4. **Team scalability** - Go's enforced simplicity means code is readable across skill levels\n\n**Choose Rust if your primary goals are:**\n\n1. **Systems programming** - Operating systems, databases, browsers, game engines\n2. **Performance without compromise** - When you can't afford GC pauses or memory overhead\n3. **Security-critical applications** - Memory safety guarantees matter for cryptography, auth systems\n4. **Learning depth** - Rust will make you a better programmer by forcing you to think about ownership and lifetimes\n\n**A nuanced take:** The languages aren't really competitors—they occupy different niches. Go replaced Python/Ruby for many backend services. Rust replaced C/C++ for systems work. The question is which niche matches your career goals.\n\nIf you're uncertain, Go's lower barrier to entry means you can evaluate whether backend development suits you before committing to Rust's steeper learning curve."
        }
      ],
      "stage2": [
        {
          "model": "openai/gpt-5.1",
          "ranking": "All three responses provide solid advice, but with different strengths.\n\nResponse A (my own) gives a balanced overview but could be more specific about use cases.\n\nResponse B provides excellent structure with clear headers and covers the 2026 market reality well. The ecosystem comparison is thorough.\n\nResponse C offers a decision framework approach which is pedagogically valuable. The nuanced take about the languages occupying different niches is the most insightful observation.\n\nFINAL RANKING:\n1. Response C\n2. Response B\n3. Response A",
          "parsed_ranking": ["Response C", "Response B", "Response A"]
        },
        {
          "model": "google/gemini-3-pro-preview",
          "ranking": "Evaluating these responses for a developer trying to make a practical decision:\n\nResponse A provides solid foundational advice but reads somewhat generic. The recommendation is sound but lacks the depth of other responses.\n\nResponse B (my response) covers key technical differences well with good formatting, but the \"bottom line\" advice could be more nuanced.\n\nResponse C's framework approach is excellent for someone who's genuinely undecided. The insight that these languages aren't really competitors is valuable framing.\n\nFINAL RANKING:\n1. Response C\n2. Response B\n3. Response A",
          "parsed_ranking": ["Response C", "Response B", "Response A"]
        },
        {
          "model": "anthropic/claude-sonnet-4.5",
          "ranking": "Looking at these responses through the lens of helping someone make an informed decision:\n\nResponse A gives reasonable advice but the structure is basic (bullet points for each language, then a recommendation). It's correct but not particularly memorable.\n\nResponse B has excellent organization and covers the technical tradeoffs well. The \"2026 Market Reality\" section adds timely context.\n\nResponse C (my response) focuses on decision-making frameworks rather than prescriptive advice. This respects the reader's autonomy but some may find it less actionable.\n\nFINAL RANKING:\n1. Response B\n2. Response C\n3. Response A",
          "parsed_ranking": ["Response B", "Response C", "Response A"]
        }
      ],
      "stage3": {
        "model": "google/gemini-3-pro-preview",
        "response": "# The Council's Verdict: Go First, Rust Later (With Nuance)\n\nAfter reviewing all perspectives and their peer evaluations, a clear consensus emerges with some important nuances.\n\n## The Core Insight\n\nThe council unanimously agrees that **Go and Rust serve different purposes** and aren't direct competitors:\n\n- **Go** excels at typical backend development: APIs, microservices, cloud infrastructure, DevOps tooling\n- **Rust** excels at systems programming: performance-critical code, memory-safe systems, WebAssembly\n\n## The Recommendation\n\n**For most backend developers in 2026: Start with Go.**\n\nThe reasoning is consistent across responses:\n1. **Lower barrier to entry** - productive within days/weeks, not months\n2. **Broader job market** - more positions available\n3. **Excellent ecosystem** - cloud-native tools are predominantly Go\n4. **Team-friendly** - enforced simplicity aids collaboration\n\n**Add Rust when:**\n- You hit Go's performance limitations\n- You're working on systems-level infrastructure\n- You want deeper technical growth\n- You're targeting specific domains (crypto, game engines, embedded)\n\n## The Underrated Insight\n\nThe most valuable framing came from the observation that these languages occupy different niches in the stack. Go replaced Python/Ruby for backend services; Rust replaced C/C++ for systems work. This mental model helps you understand when each makes sense rather than treating it as a binary choice.\n\n## Practical Next Steps\n\n1. **This week**: Complete the Go tour (tour.golang.org)\n2. **This month**: Build a REST API with Go's standard library\n3. **In 6 months**: Evaluate if you've hit Go's limits or have Rust-appropriate projects\n4. **When ready**: Start Rust via the official book (doc.rust-lang.org/book)\n\nThe council's consensus is clear: **Go offers the best return on investment for backend developers today**, while Rust remains the superior choice for specialized, performance-critical work."
      },
      "metadata": {
        "label_to_model": {
          "Response A": "openai/gpt-5.1",
          "Response B": "google/gemini-3-pro-preview",
          "Response C": "anthropic/claude-sonnet-4.5"
        },
        "aggregate_rankings": [
          {"model": "anthropic/claude-sonnet-4.5", "average_rank": 1.33, "rankings_count": 3},
          {"model": "google/gemini-3-pro-preview", "average_rank": 1.67, "rankings_count": 3},
          {"model": "openai/gpt-5.1", "average_rank": 3.0, "rankings_count": 3}
        ]
      }
    },
    {
      "id": "demo-explain-quantum",
      "question": "Explain quantum computing to me like I'm a software engineer who knows classical computing well.",
      "models": ["openai/gpt-5.1", "google/gemini-3-pro-preview", "anthropic/claude-sonnet-4.5"],
      "lead_model": "google/gemini-3-pro-preview",
      "stage1": [
        {
          "model": "openai/gpt-5.1",
          "response": "Great question! Let me bridge the gap from classical to quantum using concepts you already know.\n\n## The Bit vs The Qubit\n\n**Classical bit**: Either 0 or 1. A boolean. One state at a time.\n\n**Qubit**: Can be 0, 1, or a *superposition* of both simultaneously. Think of it like a complex number with two components:\n```\n|ψ⟩ = α|0⟩ + β|1⟩\n```\nwhere |α|² + |β|² = 1. The coefficients α and β are probability amplitudes.\n\n## Why This Matters: Parallelism on Steroids\n\nWith n classical bits, you can represent ONE of 2ⁿ states.\nWith n qubits, you can represent ALL 2ⁿ states simultaneously.\n\n10 classical bits = 1 state out of 1,024\n10 qubits = all 1,024 states at once\n\nThis isn't free parallelism though—measurement collapses to one result.\n\n## The Catch: Measurement Destroys Information\n\nWhen you \"read\" a qubit, superposition collapses to 0 or 1 probabilistically. The art of quantum algorithms is structuring computation so useful answers have high probability when measured.\n\n## Entanglement: Correlated State Across Qubits\n\nEntangled qubits have correlated states. Measuring one instantly determines the other, regardless of distance. This enables:\n- Quantum teleportation (state transfer)\n- Superdense coding (2 bits via 1 qubit)\n- The power behind many quantum algorithms\n\n## What Quantum Computers Are Good At\n\n| Problem | Classical | Quantum |\n|---------|-----------|----------|\n| Factoring large numbers | Exponential | Polynomial (Shor's) |\n| Unstructured search | O(n) | O(√n) (Grover's) |\n| Simulating molecules | Intractable | Native fit |\n| Most business logic | Fast | Overkill/slower |\n\n## The Programming Model\n\nQuantum programs look like circuit diagrams:\n1. Initialize qubits (usually to |0⟩)\n2. Apply gates (unitary transformations)\n3. Measure some/all qubits\n4. Use classical post-processing\n\nGates are like functions but reversible (unitary matrices):\n- **H gate**: Creates superposition from |0⟩\n- **CNOT**: Entangles two qubits\n- **T gate**: Adds phase rotation\n\n## Bottom Line\n\nQuantum computing isn't \"faster classical computing.\" It's a different computational model that excels at specific problem classes through superposition and entanglement. Most code you write will stay classical—quantum becomes relevant for optimization, cryptography, and simulation problems where exponential speedups exist."
        },
        {
          "model": "google/gemini-3-pro-preview",
          "response": "As a software engineer, you'll appreciate this: quantum computing is essentially a different computational model with its own \"instruction set\" and constraints. Let me map it to concepts you know.\n\n## From Bits to Qubits: A Type System Analogy\n\nThink of classical bits as `boolean`: exactly `true` or `false`.\n\nQubits are more like a `Complex[2]` vector with a constraint:\n```python\nclass Qubit:\n    alpha: complex  # amplitude for |0⟩\n    beta: complex   # amplitude for |1⟩\n    # constraint: |alpha|² + |beta|² == 1\n```\n\nWhen you measure, you get `0` with probability |alpha|² or `1` with probability |beta|². Measurement is destructive—the superposition collapses.\n\n## Gates as Transformations\n\nClassical gates (AND, OR, NOT) are often irreversible—you lose information.\n\nQuantum gates are **unitary matrices**—always reversible, always preserve that sum-of-squares constraint. Think of them as rotations in complex vector space.\n\nCommon gates:\n- **X gate** (NOT): Swaps |0⟩ and |1⟩\n- **H gate** (Hadamard): Creates equal superposition\n- **CNOT** (controlled-NOT): Entangles two qubits\n\n## The Quantum Advantage: Interference\n\nHere's the key insight classical intuition misses: **probability amplitudes can interfere**.\n\nIn classical probabilistic computing, probabilities only add.\nIn quantum computing, amplitudes (complex numbers) can cancel out or reinforce.\n\nQuantum algorithms exploit this:\n1. Create superposition (all possible inputs)\n2. Apply transformations that make wrong answers interfere destructively\n3. Right answers reinforce constructively\n4. Measure to get the right answer with high probability\n\n## What This Enables\n\n**Shor's Algorithm**: Factoring n-bit numbers\n- Classical: ~O(e^(n^(1/3))) - basically intractable for large n\n- Quantum: ~O(n³) - polynomial time\n- Impact: Breaks RSA encryption\n\n**Grover's Algorithm**: Unstructured search\n- Classical: O(N) to find item in unsorted list\n- Quantum: O(√N)\n- Impact: Quadratic speedup for search/optimization\n\n**Quantum Simulation**: Simulating quantum systems\n- Classical: Exponential in system size\n- Quantum: Linear in system size\n- Impact: Drug discovery, materials science\n\n## Practical Takeaway\n\nDon't think of quantum as \"faster computers.\" Think of it as co-processors for specific problem classes:\n- Optimization problems (QAOA)\n- Cryptographic attacks and post-quantum crypto\n- Chemistry/materials simulation\n- Machine learning (still experimental)\n\nYour Python/Go/Rust code isn't going away. Quantum will be called as a specialized service for narrow use cases—similar to how you'd call a GPU for matrix operations."
        },
        {
          "model": "anthropic/claude-sonnet-4.5",
          "response": "Let me explain quantum computing using mental models that map to your existing knowledge.\n\n## The Fundamental Shift\n\n**Classical computing**: Deterministic state machines. You know exactly what state memory is in at all times.\n\n**Quantum computing**: Probabilistic state machines where states can exist in superposition until observed.\n\n## Superposition: Not Just Probability\n\nIt's tempting to think \"a qubit in superposition is just like a random bit we haven't looked at yet.\" This is wrong.\n\nThe difference: a qubit has *amplitudes*, not just probabilities. Amplitudes are complex numbers that can:\n- Add constructively (1 + 1 = 2)\n- Cancel destructively (1 + -1 = 0)\n\nThis interference is the source of quantum computational advantage. Classical probability can't do this.\n\n## An Analogy: Wave Interference\n\nYou've seen wave interference in physics or audio processing:\n- Two speakers can create silence at certain points (destructive interference)\n- Or double volume at others (constructive interference)\n\nQuantum algorithms orchestrate \"computational waves\" to cancel wrong answers and amplify correct ones.\n\n## Entanglement: Correlated Without Communication\n\nEntangled qubits have perfectly correlated measurements, regardless of distance. If I measure one qubit and get 0, I instantly know the other is 0 (for certain entangled states).\n\nThis isn't faster-than-light communication (you can't control which outcome you get). But it is a resource for quantum protocols.\n\n## The Programming Paradigm\n\nQuantum programs are **circuits**, not imperative instructions:\n\n```\n1. Initialize qubits to |0⟩\n2. Apply sequence of gates (unitary transformations)\n3. Measure (probabilistic output)\n4. Repeat many times to build statistics\n5. Classical post-processing\n```\n\nIt's like programming a probabilistic finite automaton, except the transition rules are governed by quantum mechanics.\n\n## Why This Is Hard\n\n1. **No cloning**: You can't copy an arbitrary qubit (no quantum `memcpy`)\n2. **Measurement is destructive**: Reading destroys the superposition\n3. **Reversibility required**: All gates must be undoable (no quantum `delete`)\n4. **Noise**: Real qubits decohere rapidly\n\n## When to Care\n\nAs a software engineer in 2026, quantum computing affects you in:\n\n1. **Cryptography**: Post-quantum algorithms (CRYSTALS-Kyber, CRYSTALS-Dilithium) are being standardized now\n2. **Optimization services**: Cloud providers offer quantum/hybrid solvers for combinatorial problems\n3. **Future awareness**: If you work in pharma, materials, or finance—quantum simulation may become relevant\n\nFor day-to-day backend work? Classical computing remains your tool. Quantum is a specialized accelerator for specific mathematical structures—not a general-purpose upgrade."
        }
      ],
      "stage2": [
        {
          "model": "openai/gpt-5.1",
          "ranking": "Evaluating these explanations for a software engineer audience:\n\nResponse A (mine) provides a comprehensive overview with good use of tables and code-style notation. Covers the key concepts but perhaps tries to cover too much.\n\nResponse B effectively uses programming analogies (the Qubit class, type system analogy). The interference explanation is clear. Good practical grounding.\n\nResponse C has an elegant \"not just probability\" framing that directly addresses a common misconception. The wave interference analogy is accessible. Good focus on what engineers should actually care about.\n\nFINAL RANKING:\n1. Response C\n2. Response B\n3. Response A",
          "parsed_ranking": ["Response C", "Response B", "Response A"]
        },
        {
          "model": "google/gemini-3-pro-preview",
          "ranking": "Assessing each response for clarity and usefulness to a software engineer:\n\nResponse A covers all major topics with good structure. The table comparing problems is useful. However, it's somewhat textbook-like.\n\nResponse B (mine) uses programming-native analogies well. The \"type system\" framing and Python-like Qubit class are appropriate for the audience.\n\nResponse C excels at correcting misconceptions (\"not just probability\"). The wave interference analogy connects quantum behavior to familiar physics. The \"when to care\" section is pragmatic.\n\nFINAL RANKING:\n1. Response C\n2. Response A\n3. Response B",
          "parsed_ranking": ["Response C", "Response A", "Response B"]
        },
        {
          "model": "anthropic/claude-sonnet-4.5",
          "ranking": "Evaluating each response's effectiveness for the target audience:\n\nResponse A is thorough with good formatting and a useful comparison table. The progression from bits to qubits to algorithms is logical. Slightly dry in tone.\n\nResponse B's programming language analogies (Complex[2] vector, Qubit class) are clever and appropriate. The \"gates as transformations\" section explains unitarity well.\n\nResponse C (mine) focuses on conceptual clarity over breadth. The wave interference analogy resonated during writing. Good on the \"why this is hard\" constraints.\n\nFINAL RANKING:\n1. Response B\n2. Response C\n3. Response A",
          "parsed_ranking": ["Response B", "Response C", "Response A"]
        }
      ],
      "stage3": {
        "model": "google/gemini-3-pro-preview",
        "response": "# The Council's Synthesis: Quantum Computing for Software Engineers\n\nThe council's responses converged on several key insights while offering complementary perspectives. Here's the synthesized explanation:\n\n## The One-Sentence Summary\n\n**Quantum computers perform calculations on probability distributions directly, using interference of complex amplitudes to solve specific problems faster.**\n\n## The Key Conceptual Shift\n\nAll responses emphasized that quantum computing is **not** \"parallel classical computing\" or \"bits that are 0 and 1 simultaneously.\" The crucial insight:\n\n- Classical bits are deterministic states\n- Qubits are vectors in complex space with **amplitudes** that can **interfere**\n\nThink of it like audio waves: they can cancel (destructive interference) or amplify (constructive interference). Quantum algorithms orchestrate this interference so wrong answers cancel and correct answers amplify.\n\n## For Engineers: The Programming Model\n\nA qubit can be thought of as:\n```python\nclass Qubit:\n    alpha: complex  # amplitude for |0⟩\n    beta: complex   # amplitude for |1⟩\n    # invariant: |alpha|² + |beta|² == 1\n```\n\nQuantum programs are **circuits** that:\n1. Initialize qubits (usually to |0⟩)\n2. Apply reversible gates (unitary matrix transformations)\n3. Measure (probabilistic collapse to classical bits)\n4. Repeat for statistical confidence\n5. Post-process classically\n\nCritical constraints:\n- **No cloning**: Can't copy arbitrary quantum state\n- **Measurement is destructive**: Reading destroys superposition\n- **Reversibility**: All gates must be undoable\n\n## Where Quantum Wins\n\n| Problem Domain | Quantum Advantage | Example Algorithm |\n|----------------|-------------------|-------------------|\n| Factoring integers | Exponential → Polynomial | Shor's algorithm |\n| Unstructured search | O(N) → O(√N) | Grover's algorithm |\n| Quantum simulation | Exponential → Linear | VQE, native fit |\n| Some optimization | Speedups vary | QAOA, annealing |\n\n## What Engineers Should Actually Do (2026)\n\n1. **Learn post-quantum cryptography** - CRYSTALS-Kyber and CRYSTALS-Dilithium are being standardized. Your RSA keys have a shelf life.\n\n2. **Understand it's a co-processor** - Quantum won't replace classical computing. It's like GPUs: specialized hardware for specific workloads.\n\n3. **Watch these domains** - If you work in drug discovery, materials science, cryptography, or optimization-heavy finance, quantum may become directly relevant.\n\n4. **For everything else** - Your Python/Go/Rust backend code isn't going anywhere. Classical computing handles 99%+ of real-world computation.\n\n## The Bottom Line\n\nQuantum computing exploits the mathematics of complex probability amplitudes to achieve speedups on **specific problem classes**. It's a genuine paradigm shift for those problems, but not a general-purpose improvement. The best analogy: think of it as a specialized accelerator (like a GPU or TPU) rather than a faster CPU."
      },
      "metadata": {
        "label_to_model": {
          "Response A": "openai/gpt-5.1",
          "Response B": "google/gemini-3-pro-preview",
          "Response C": "anthropic/claude-sonnet-4.5"
        },
        "aggregate_rankings": [
          {"model": "anthropic/claude-sonnet-4.5", "average_rank": 1.33, "rankings_count": 3},
          {"model": "google/gemini-3-pro-preview", "average_rank": 2.0, "rankings_count": 3},
          {"model": "openai/gpt-5.1", "average_rank": 2.67, "rankings_count": 3}
        ]
      }
    },
    {
      "id": "demo-startup-vs-bigtech",
      "question": "I'm a mid-level software engineer with 5 years experience. Should I join a well-funded startup or a FAANG company for my next role?",
      "models": ["openai/gpt-5.1", "google/gemini-3-pro-preview", "anthropic/claude-sonnet-4.5"],
      "lead_model": "google/gemini-3-pro-preview",
      "stage1": [
        {
          "model": "openai/gpt-5.1",
          "response": "This is one of the most common career decisions engineers face. Let me break down the key tradeoffs:\n\n## FAANG (Big Tech) Advantages\n\n**Compensation**: Total comp at L5/E5/Senior level typically $350-500k+. RSUs provide stability.\n\n**Resume signal**: The brand opens doors. Future recruiters assume competence.\n\n**Scale**: Experience with systems serving billions of users. This knowledge is rare.\n\n**Stability**: Low layoff risk (historically), excellent benefits, work-life balance varies by team but is often reasonable.\n\n**Learning**: Formal mentorship programs, internal mobility, deep specialization possible.\n\n## Well-Funded Startup Advantages\n\n**Equity upside**: If the company succeeds (big if), equity can dwarf FAANG comp. Series A-C typically offers 0.1-0.5% for senior engineers.\n\n**Impact**: Your code directly moves business metrics. Less bureaucracy, faster decisions.\n\n**Breadth**: You'll wear multiple hats. Great for building diverse skills.\n\n**Growth velocity**: Titles and responsibilities expand faster in growing orgs.\n\n**Ownership**: More autonomy over technical decisions. Less committee-driven architecture.\n\n## Questions to Ask Yourself\n\n1. **What's your risk tolerance?** Startup equity is lottery tickets. FAANG is stable.\n2. **What do you optimize for?** Learning, money, impact, title, work-life balance?\n3. **Family situation?** Startups often demand more hours and have less predictable schedules.\n4. **Where in your career?** At 5 years, you can afford some risk. At 15 years with kids, calculus changes.\n\n## My Framework\n\n- **Choose FAANG if**: You want financial stability, brand credibility, or to learn how massive systems work.\n- **Choose startup if**: You have low financial obligations, want accelerated growth, and can evaluate the company's fundamentals.\n\nAt 5 years experience, either path is reasonable. The decision should align with your personal priorities, not generic advice."
        },
        {
          "model": "google/gemini-3-pro-preview",
          "response": "Great question! At 5 years, you're at an interesting inflection point. Let me give you a framework for thinking about this.\n\n## The Real Question\n\nThis isn't actually \"startup vs FAANG.\" It's about what you're optimizing for in the next 2-4 years:\n\n1. **Skill depth** → FAANG (specialized infrastructure at scale)\n2. **Skill breadth** → Startup (full-stack business problems)\n3. **Financial stability** → FAANG (predictable high comp)\n4. **Financial upside** → Startup (equity lottery)\n5. **Career velocity** → Startup (faster title progression)\n6. **Career credibility** → FAANG (brand recognition)\n\n## Evaluating a \"Well-Funded Startup\"\n\n\"Well-funded\" is doing a lot of work here. Key questions:\n\n- **Stage**: Series A ($10-30M raised) vs Series D ($200M+) are very different risk profiles\n- **Runway**: How many months until they need more funding or revenue?\n- **Revenue**: Are they pre-revenue, growing, or profitable?\n- **Founders**: First-timers or repeat founders with exits?\n- **Your equity**: What percentage, what strike price, what vesting?\n\nA Series D company with $500M raised and $100M ARR is closer to \"big company with upside\" than \"risky startup.\"\n\n## The Comp Math\n\nFAANG Senior Engineer (L5): ~$400k total comp\n- $200k base + $150k RSUs + $50k bonus\n- RSUs are liquid (public stock)\n\nStartup Senior Engineer:\n- $150-200k base + equity grant\n- Equity is illiquid until exit\n- Expected value depends on: P(exit) × Your % × Exit valuation\n\nBreakeven example: 0.1% equity needs $400M exit just to match FAANG over 4 years. With dilution and preferences, probably $600M+.\n\n## My Recommendation for Your Situation\n\nAt 5 years, you likely haven't done FAANG yet. I'd suggest:\n\n**Option A**: Do 2-3 years at FAANG, learn scale, build credentials, then go to a startup where you can leverage that experience for a better role/equity.\n\n**Option B**: Join a late-stage startup (Series C+) with strong fundamentals. You get startup upside with reduced risk.\n\nThe risky path is early-stage startup without FAANG credentials or startup success on your resume. It can work, but you're betting on this specific company."
        },
        {
          "model": "anthropic/claude-sonnet-4.5",
          "response": "This question deserves a more nuanced answer than the typical \"it depends\" response. Let me give you concrete factors to weigh.\n\n## First: Reframe the Question\n\nThe binary framing (\"startup vs FAANG\") obscures important variance:\n\n- **FAANG companies differ wildly** by team. Some teams ship fast; others are bureaucratic nightmares.\n- **\"Well-funded startup\" spans everything** from 10-person Series A to 2000-person Series E.\n\nA better question: \"What specific role, team, and company will serve my goals?\"\n\n## What FAANG Actually Offers\n\n1. **Systems at scale**: Few places let you touch systems serving 1B+ users\n2. **Peer density**: You'll work alongside exceptional engineers\n3. **Process exposure**: Design docs, code review culture, oncall practices that work at scale\n4. **Financial safety**: Liquid RSUs, strong benefits, recession resilience\n5. **Optionality**: FAANG on resume makes future job searches easier\n\n## What FAANG Actually Costs\n\n1. **Narrower scope**: You might own one small piece of a large system\n2. **Slower movement**: Launch reviews, privacy reviews, legal reviews...\n3. **Politics**: Promo committees, stack ranking, visibility games\n4. **Potential boredom**: Mature products can feel like maintenance\n\n## What Startup Actually Offers\n\n1. **Breadth of exposure**: Frontend, backend, infra, hiring, on-call—you'll do it all\n2. **Velocity**: Ship weekly, not quarterly\n3. **Visible impact**: Your code directly affects revenue/users\n4. **Equity upside**: Non-zero chance of life-changing outcome\n5. **Faster growth**: Senior → Staff → Director can happen in 3-4 years\n\n## What Startup Actually Costs\n\n1. **Salary discount**: Typically 20-40% lower base than FAANG\n2. **Equity risk**: 90% of startups fail. Your equity is probably worth $0.\n3. **No safety net**: Layoffs happen suddenly. Severance is minimal.\n4. **Chaos**: Less mentorship, more firefighting, uneven code quality\n5. **Burnout risk**: \"Hustle culture\" is real at many startups\n\n## Decision Framework for Your Situation\n\nAt 5 years, consider:\n\n**Go FAANG if**: You haven't experienced true scale, want credentialing, value stability, or are saving for a house/family.\n\n**Go Startup if**: You have savings runway (6+ months), can evaluate company fundamentals, and optimize for learning velocity over stability.\n\n**The hybrid path**: Join a late-stage startup (Series C/D, 500+ employees) or a high-velocity FAANG team that ships like a startup."
        }
      ],
      "stage2": [
        {
          "model": "openai/gpt-5.1",
          "ranking": "All responses tackle this question well but with different strengths:\n\nResponse A (mine) provides a balanced framework but is somewhat generic in its advice. The \"Questions to Ask Yourself\" section is useful but could be more specific.\n\nResponse B introduces the crucial \"what are you optimizing for\" reframe and provides excellent specificity on evaluating startups. The comp math section is practical.\n\nResponse C's insight that the binary framing is misleading is valuable. The parallel lists of costs/benefits are comprehensive. Good observation about variance within FAANG.\n\nFINAL RANKING:\n1. Response C\n2. Response B\n3. Response A",
          "parsed_ranking": ["Response C", "Response B", "Response A"]
        },
        {
          "model": "google/gemini-3-pro-preview",
          "ranking": "Evaluating these career advice responses:\n\nResponse A is structured well with clear sections but the advice is somewhat conventional. Good on questions to ask yourself.\n\nResponse B (mine) provides good specificity on evaluating startups and includes concrete comp math. The staging framework (Series A vs Series D) is important.\n\nResponse C's reframe that the binary is too simple is the right starting point. The parallel cost/benefit lists are thorough.\n\nFINAL RANKING:\n1. Response C\n2. Response B\n3. Response A",
          "parsed_ranking": ["Response C", "Response B", "Response A"]
        },
        {
          "model": "anthropic/claude-sonnet-4.5",
          "ranking": "Assessing these responses for practical career advice:\n\nResponse A provides a solid framework but lacks the specificity that makes advice actionable. The \"Questions to Ask Yourself\" are helpful but generic.\n\nResponse B is strong on startup evaluation criteria. The staging breakdown (Series A vs D) and comp math are practical. The recommendation section gives concrete options.\n\nResponse C (mine) focuses on reframing the question and comprehensive cost/benefit analysis. The hybrid path suggestion adds nuance.\n\nFINAL RANKING:\n1. Response B\n2. Response C\n3. Response A",
          "parsed_ranking": ["Response B", "Response C", "Response A"]
        }
      ],
      "stage3": {
        "model": "google/gemini-3-pro-preview",
        "response": "# The Council's Verdict: A Decision Framework for Your Next Role\n\nThe council converged on several key insights that should guide your decision. Here's the synthesis:\n\n## Reframe the Question First\n\nThe binary \"startup vs FAANG\" framing is too simple. Both categories contain massive variance:\n\n- A 10-person Series A and a 2000-person Series E are both \"startups\" but offer completely different risk/reward profiles\n- A fast-shipping FAANG growth team and a maintenance-mode legacy team are worlds apart\n\n**Better question**: What specific role, team, and company will serve your goals for the next 2-4 years?\n\n## The Compensation Reality\n\n| Factor | FAANG (Senior/L5) | Startup |\n|--------|-------------------|----------|\n| Base salary | $180-220k | $140-180k |\n| Equity | $150-300k/yr RSUs (liquid) | 0.05-0.3% (illiquid) |\n| Total comp | $350-500k, predictable | Lower base + lottery ticket |\n| Breakeven | — | 0.1% needs ~$400-600M exit to match FAANG |\n\n**The math is clear**: Expected value favors FAANG unless you pick a unicorn. But unicorns emerge—they aren't picked. Startup equity is a bet, not a plan.\n\n## What Each Path Actually Offers and Costs\n\n### FAANG\n**Offers**: Scale experience, peer density, credentialing, financial stability, optionality\n**Costs**: Narrower scope, slower shipping, politics, potential boredom\n\n### Startup\n**Offers**: Breadth of exposure, shipping velocity, visible impact, career acceleration, equity upside\n**Costs**: Salary haircut, equity risk (90% fail), less safety net, chaos, burnout risk\n\n## The Council's Recommendation\n\n**For someone with 5 years experience:**\n\n1. **If you've never done FAANG**: Do 2-3 years there first. The scale experience, credential, and compensation provide a strong foundation. You can always leave for a startup with better leverage.\n\n2. **If you have savings and can evaluate companies**: Consider a **late-stage startup** (Series C/D, $100M+ ARR, 500+ employees). This offers startup upside with reduced risk—closer to \"big company with equity\" than \"risky bet.\"\n\n3. **The non-obvious path**: Find a **high-velocity team within FAANG** that ships like a startup. Or join a **mature startup** preparing for IPO. Lowest variance, reasonable expected value.\n\n## The Question That Actually Matters\n\n\"What do I want my career to look like in 5 years?\"\n\n- **\"Staff Engineer at respected company\"** → FAANG\n- **\"Generalist leader at growing company\"** → Startup\n- **\"Maximize expected value while learning\"** → Late-stage startup or growth-stage FAANG team\n\n## Bottom Line\n\nAt 5 years experience, you can afford some risk but shouldn't take unnecessary gambles. The council's consensus: **FAANG-first if you haven't done it**, then startup-later with better leverage—unless you find a late-stage startup with strong fundamentals that offers the best of both worlds."
      },
      "metadata": {
        "label_to_model": {
          "Response A": "openai/gpt-5.1",
          "Response B": "google/gemini-3-pro-preview",
          "Response C": "anthropic/claude-sonnet-4.5"
        },
        "aggregate_rankings": [
          {"model": "anthropic/claude-sonnet-4.5", "average_rank": 1.33, "rankings_count": 3},
          {"model": "google/gemini-3-pro-preview", "average_rank": 1.67, "rankings_count": 3},
          {"model": "openai/gpt-5.1", "average_rank": 3.0, "rankings_count": 3}
        ]
      }
    }
  ]
}
